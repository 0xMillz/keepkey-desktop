diff --git a/dist/ethereum.js b/dist/ethereum.js
index 0fb3ad478ffc098adc4e3eca2da74c91fe60d6ea..39421133a0328e5b48a16e901cc7eca67f71a87f 100644
--- a/dist/ethereum.js
+++ b/dist/ethereum.js
@@ -213,70 +213,72 @@ function ethSignMessage(transport, msg) {
 exports.ethSignMessage = ethSignMessage;
 function ethSignTypedData(transport, msg) {
     return __awaiter(this, void 0, void 0, function* () {
-        /**
-         * If the message to be signed is sufficiently small, the KeepKey can calculate the
-         * domain separator and message hashes. Otherwise, we need to pre-calculate hashes
-         * here and verify on device.
-         */
-        const sTypes = JSON.stringify({ types: msg.typedData.types });
-        const sPrimaryType = JSON.stringify({ primaryType: msg.typedData.primaryType });
-        const sDomain = JSON.stringify({ domain: msg.typedData.domain });
-        const sMessage = JSON.stringify({ message: msg.typedData.message });
-        try {
-            if (sTypes.length > 2048 || sPrimaryType.length > 80 || sDomain.length > 2048 || sMessage.length > 2048) {
-                /* Pre-calculate domain separator and messages hashes and verify on KeepKey */
-                const domainSeparatorHash = eip_712_1.getTypeHash(msg.typedData, "EIP712Domain");
-                const domainSeparatorHash64 = Buffer.from(domainSeparatorHash).toString("base64");
-                const messageHash = eip_712_1.getMessage(msg.typedData, true);
-                const messageHash64 = Buffer.from(messageHash).toString("base64");
-                const t = new Ethereum.EthereumSignTypedHash();
-                t.setAddressNList(msg.addressNList);
-                t.setDomainSeparatorHash(domainSeparatorHash64);
-                t.setMessageHash(messageHash64);
-                const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNTYPEDHASH, t, {
-                    msgTimeout: core.LONG_TIMEOUT,
-                });
-                const result = response.proto;
-                const res = {
-                    address: result.getAddress() || "",
-                    signature: "0x" + core.toHexString(result.getSignature_asU8()),
-                };
-                return res;
+        return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {
+            /**
+             * If the message to be signed is sufficiently small, the KeepKey can calculate the
+             * domain separator and message hashes. Otherwise, we need to pre-calculate hashes
+             * here and verify on device.
+             */
+            const sTypes = JSON.stringify({ types: msg.typedData.types });
+            const sPrimaryType = JSON.stringify({ primaryType: msg.typedData.primaryType });
+            const sDomain = JSON.stringify({ domain: msg.typedData.domain });
+            const sMessage = JSON.stringify({ message: msg.typedData.message });
+            try {
+                if (sTypes.length > 2048 || sPrimaryType.length > 80 || sDomain.length > 2048 || sMessage.length > 2048) {
+                    /* Pre-calculate domain separator and messages hashes and verify on KeepKey */
+                    const domainSeparatorHash = eip_712_1.getTypeHash(msg.typedData, "EIP712Domain");
+                    const domainSeparatorHash64 = Buffer.from(domainSeparatorHash).toString("base64");
+                    const messageHash = eip_712_1.getMessage(msg.typedData, true);
+                    const messageHash64 = Buffer.from(messageHash).toString("base64");
+                    const t = new Ethereum.EthereumSignTypedHash();
+                    t.setAddressNList(msg.addressNList);
+                    t.setDomainSeparatorHash(domainSeparatorHash64);
+                    t.setMessageHash(messageHash64);
+                    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNTYPEDHASH, t, {
+                        msgTimeout: core.LONG_TIMEOUT,
+                    });
+                    const result = response.proto;
+                    const res = {
+                        address: result.getAddress() || "",
+                        signature: "0x" + core.toHexString(result.getSignature_asU8()),
+                    };
+                    return res;
+                }
+                else {
+                    /* Let KeepKey calculate domain separator and message hashes */
+                    const dsh = new Ethereum.Ethereum712TypesValues();
+                    dsh.setAddressNList(msg.addressNList);
+                    dsh.setEip712types(sTypes);
+                    dsh.setEip712primetype(sPrimaryType);
+                    dsh.setEip712data(sDomain);
+                    dsh.setEip712typevals(1);
+                    let response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUM712TYPESVALUES, dsh, {
+                        msgTimeout: core.LONG_TIMEOUT,
+                        omitLock: true,
+                    });
+                    const mh = new Ethereum.Ethereum712TypesValues();
+                    mh.setAddressNList(msg.addressNList);
+                    mh.setEip712types(sTypes);
+                    mh.setEip712primetype(sPrimaryType);
+                    mh.setEip712data(sMessage);
+                    mh.setEip712typevals(2);
+                    response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUM712TYPESVALUES, mh, {
+                        msgTimeout: core.LONG_TIMEOUT,
+                        omitLock: true,
+                    });
+                    const result = response.proto;
+                    const res = {
+                        address: result.getAddress() || "",
+                        signature: "0x" + core.toHexString(result.getSignature_asU8()),
+                    };
+                    return res;
+                }
             }
-            else {
-                /* Let KeepKey calculate domain separator and message hashes */
-                const dsh = new Ethereum.Ethereum712TypesValues();
-                dsh.setAddressNList(msg.addressNList);
-                dsh.setEip712types(sTypes);
-                dsh.setEip712primetype(sPrimaryType);
-                dsh.setEip712data(sDomain);
-                dsh.setEip712typevals(1);
-                let response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUM712TYPESVALUES, dsh, {
-                    msgTimeout: core.LONG_TIMEOUT,
-                    omitLock: true,
-                });
-                const mh = new Ethereum.Ethereum712TypesValues();
-                mh.setAddressNList(msg.addressNList);
-                mh.setEip712types(sTypes);
-                mh.setEip712primetype(sPrimaryType);
-                mh.setEip712data(sMessage);
-                mh.setEip712typevals(2);
-                response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUM712TYPESVALUES, mh, {
-                    msgTimeout: core.LONG_TIMEOUT,
-                    omitLock: true,
-                });
-                const result = response.proto;
-                const res = {
-                    address: result.getAddress() || "",
-                    signature: "0x" + core.toHexString(result.getSignature_asU8()),
-                };
-                return res;
+            catch (error) {
+                console.error({ error });
+                throw new Error("Failed to sign typed ETH message");
             }
-        }
-        catch (error) {
-            console.error({ error });
-            throw new Error("Failed to sign typed ETH message");
-        }
+        }));
     });
 }
 exports.ethSignTypedData = ethSignTypedData;
